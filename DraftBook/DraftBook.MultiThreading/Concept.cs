using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DraftBook.MultiThreading
{
    /// <summary>
    /// 多线程中的一些概念问题
    /// </summary>
    class Concept
    {
        //对多线程的一些误区：
        //1、多线程并不一定会是代码变快，因为目前的CPU都是使用时间片轮转的技术执行任务，并且每创建一个线程意味着就需要多分配对应的内存，如果滥用反而会造成性能损耗，因为一共能能够分配的内存是固定的，并且CPU将大量的时间用在从一个线程切换到另一个线程，而不是执行任务
        //2、多线程的难点：多线程的难点一般是在单线程情况下一些成立的假设在多线程的下就不成立了，主要包括缺乏原子性、静态竞争、复杂的内存模型以及死锁。
            //a. 原子性就不多说了，就是两个线程同时访问一段代码时，肯定是无法做到一致性的，原子性我在这泛泛地认为是事务性。
            //b. 静态竞争这个点之前完全没有意识，作者的大概意思就是如果两个并行的线程需要同时访问一个资源，在不加入线程同步的控制流下，CPU就会随机进行分配，有可能第一个线程已经执行完毕了但是第二个线程还没有开始，也有可能99.9%的情况下执行都正确的，但是就有0.1%的情况执行失败。
            //c. 内存模型复杂性，第一次看书的时候完全没有看这个概念，这个概念的中讲到了一个知识点，就是现代CPU需要访问一个变量的时候不是直接访问主存储器的，而是在高级缓存中创建一个变量的副本，然后副本进行定时同步。这样就有一个问题，如果两个线程在两个不同的进程中，由于每个进程是有自己的内存并且不能互相干涉的，所以当两个线程访问相同的变量时，都会在自己的高级缓存中访问自己的副本，但是由于同步的机制不同，有可能产生两个变量不同的情况，这也是一种竞态竞争。
            //d. 死锁的概念是建立在上述的问题通过锁的功能解决的情况下产生的另一种问题，C#中处理竞态等问题使用lock语句，在lock中的资源只能由一个线程访问，其余请求该资源的线程会挂起。这样就有产生一个问题：现在有a、b两种资源x线程的访问过程是a->b，y线程的访问过程是b->a，且a、b都有锁，这样如果x与y同时执行的话，有可能就会x在a内请求b被挂起，但是此时y在b内请求a也被挂起，这样就死锁了。
        
        //BCL中的ThreadPool类的缺点：
        //1、由于任务是通过ThreadPool.QueueUserWorkItem(执行委托)静态方法完成，所以代码中我们将无法获取到"执行委托"的执行结果进行同步，因此我们也无法得知到底什么时候这个"执行委托"能够执行完毕。作者在示例代码中使用了"穷人的同步"方式，通过Thread.Sleep()方法等待"执行委托"完成。但是他说这样的代码在生产环境中是不可用的，所以综上可知，线程池虽然能够管理线程的调用和回收，但是所执行的任务必须是小型的，作者说执行时间应该使用毫秒或者秒来记录，而不是小时或天。
        //2、如果大量的使用线程池资源，则会出现所有的线程都被分配并且还有任务的情况，这样就会产生等待执行的延迟。
        //3、因此，作者的意思是ThreadPool是用来进一步封装的和抽象之后才能在生产代码中使用的，其封装和抽象的结果就是TPL（Task Parallel Library 任务并行库）

        //以前一直混淆的一些概念：
        //1、Task本来就是异步的，之前一直以为只有加了async和await关键字的方法以及Async结尾的方法才是异步的。这次看书发现这种观点是错误的。Task和委托的唯一区别就是Task是异步的。作者将之前线程池异步for循环输出的示例使用Task.Run()开始重写了一遍之后可以看到代码同样是异步执行的。也就是说，所有返回Task<T>的方法中，直接result.Run()就可以异步调用了。
        //2、taskObj.Wait()相当于threadObj.Join()，这点之前是理解的。但是之前一直以为这两个方法是异步线程等待主线程。其实不是的，书中的意思可以理解为，taskObj.Wait()方法相当于taskObj被主线程等待的意思，也就是说这个Wait和Join方法都是主线程等待异步线程完成的标志。多个Task任务下只用静态方法Task.WaitAny()和Task.WaitAll()
        //3、使用TPL库编写异步方法的时候，不是取消了线程池的概念，而是系统自动从线程池中获取一个线程为Task工作，具体是回收的线程还是等待之前的线程结束后使用，这点由系统自动判断使用最优解。所以，线程池的概念依然存在，只是被封装了，使用者看不到了而已。
        //4、轮询获取异步Task<T>的执行结果。从书中的讲解中可以知道，轮询获取结果其实就是我最早写的那个导出数据的winform程序中，主线程死循环获取结果的方法（实测那次使用是失败的，并没有获取到）。
        //5、多线程会产生一个类型为AggregateException聚合异常，其中就包括一个异步任务中所有触发之后的异常，可以在主线程捕获这个异常并且进行处理，使用Handle方法进行断言。
    }
}
